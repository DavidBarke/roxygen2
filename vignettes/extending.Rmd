---
title: "Extending roxygen2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Extending roxygen2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(comment = "#>", collapse = TRUE)
```

## Basics

Roxygen is extensible with user-defined __roclets__. 
It means that you can take advantage of Roxygen's parser and extend it with your own `@tags`.

Note that's not currently possible to extend an existing roclet, so you need to create your own if you want to add new features. This restriction may be relaxed in the future.

```{r setup}
library(roxygen2)
```

## Key data structures

Before we talk about creating your own roclets, we need to first discuss two important data structures that power roxygen: blocks and tags.

### Tags

A tag (a list with S3 class `roxy_tag`) represents a single tag. 
It contains:

* `tag`: the name of the tag.

* `raw`: the raw contents of the tag (i.e. everything from the end of 
  this tag to the begining of the net).
  
* `val`: the parsed value, which we'll come back to shortly.

* `file` and `line`: the location of the tag in the package. Used
  with `roxy_tag_warning()` to produce informative error messages.

You _can_ construct tag objects by hand with `roxy_tag()`:

```{r}
roxy_tag("name", "Hadley")
str(roxy_tag("name", "Hadley"))
```

However, you should rarely need to do so, because you'll typically have them given to you in a block object

## Blocks

A block (a list with S3 class `roxy_block`) represents a single roxygen block. It contains:

* `tags`: a list of `roxy_tags`.
* `call`: the R code associated with the block (usually a function call).
* `file` and `line`: the location of the R code.
* `object`: the evaluated R object associated with the code.

The easiest way to see the basic structure of a `roxy_block()` is to generate one by parsing a roxygen block:

```{r}
text <- "
  #' This is a title
  #'
  #' @param x,y A number
  #' @export
  f <- function(x, y) x + y
"

# parse_text() returns a list of blocks, so I extract the first
block <- parse_text(text)[[1]]
block
```

## Roclets

To create your own

Running a roclet consists of multiple parts as documented in `?roclet`. 
Very briefly, a roclet can implement a number of functions (please refer to `?roclet` for details):

* `roclet_tags()`: named list of tags whose values are tag parsing functions (optional to implement)
* `roclet_preprocess()`: called after blocks have been parsed but before code has been evaluated (optional to implement)
* `roclet_process()`: called after `@eval` tag has been processed (main functionality)
* `roclet_output()`: produces files on disk based on the result from `roclet_process()` (output functionality)

Depending on the roclet, there may be some work in managing files, ensuring that no existing files are over-written, deleted etc. That must be handled, too. 
Be sure not to change or delete something that you did not create with the explicit 
disclaimer that the content can be modified or deleted. 
Roxy does this by the header (first line of the file) containing "`Generated by roxygen2: do not edit by hand`".

A roclet will use a list of tag parsers to process the written documentation. 
Internally, roxygen creates a `roxy_tag()` which is then passed on to the 
tag parser specified.

### Custom tags

In this example we will make a new `@memo` tag to enable printing the memos at the console when the roclet runs.
As you will see, testing a complete workflow of a roclet can be a bit cumbersome. 

We choose that the `@memo` has this syntax:

```
@memo [Headline] Description
```

As an example:

```
@memo [EFFICIENCY] Currently brute-force; find better algorithm.
```

The idea is that all memos with the same headline are grouped together.

```{r, eval = FALSE}
memo_roclet <- function() {
  roxygen2::roclet("memo")
}

# Based on roxygen2:::tag_name_description
tag_memo <- function(x) {
  stopifnot(grepl("^\\[.*\\].*$", x$val))
  
  parsed <- stringi::stri_match(str = x$val, regex = "\\[(.*)\\](.*)")[1, ]

  x$val <- list(
    header = parsed[[2]], 
    message = parsed[[3]]
  )
  x
}

roclet_tags.roclet_memo <- function(x) {
  list(memo = tag_memo)
}

roclet_process.roclet_memo <- function(x, blocks, env, base_path, global_options = list()) {
  results <- list()
  
  for (block in blocks) {
    tags <- block_get_tags(block, "memo")

    for (tag in tags) {
      msg <- paste0("[", tag$file, ":", tag$line, "] ", tag$val$message)
      results[[tag$val$header]] <- c(results[[tag$val$header]], msg)
    }
  }
  
  results
}

roclet_output.roclet_memo <- function(x, results, base_path, ...) {
  for (header in names(results)) {
    messages <- results[[header]]
    cat(paste0(header, ": ", "\n"))
    cat(paste0(" * ", messages, "\n", collapse = ""))
  }

  invisible(NULL)
}

results <- roc_proc_text(memo_roclet(), "
#' @memo [TBI] Remember to implement this!
#' @memo [API] Check best API
f <- function(x, y) {
  # ...
}

#' @memo [API] Consider passing z option
g <- function(x, y) {
  # ...
}
")
roclet_output(memo_roclet(), results)
```


